// Generated by diesel_ext
#![allow(unused)]
#![allow(clippy::all)]
use super::schema::{
    indexer_deployment_schemas, indexer_deployments, indexers, unused_deployments,
};
use diesel::data_types::PgTimestamp;
use diesel::insert_into;
use diesel::pg::Pg;
use diesel::serialize::{Output, ToSql};
use diesel::sql_types::{Integer, Text};
use diesel::types::FromSql;
use diesel_derive_enum::DbEnum;
use massbit_common::prelude::{bigdecimal::BigDecimal, uuid::Uuid};
use serde_derive::{Deserialize, Serialize};
use std::fmt;
use std::io::Write;

#[derive(DbEnum, Debug, Clone, Copy, Serialize, Deserialize)]
pub enum IndexerHealth {
    Failed,
    Healthy,
    Unhealthy,
}
impl Default for IndexerHealth {
    fn default() -> IndexerHealth {
        IndexerHealth::Healthy
    }
}
// define your enum
#[derive(DbEnum, Clone, Debug, Serialize, Deserialize)]
pub enum IndexerStatus {
    Draft, // All variants must be fieldless
    Deploying,
    Deployed,
    Stopped,
    Invalid,
}

impl Default for IndexerStatus {
    fn default() -> IndexerStatus {
        IndexerStatus::Draft
    }
}
#[derive(Clone, Debug, PartialEq, Eq, Hash, AsExpression, FromSqlRow, Deserialize, Serialize)]
#[sql_type = "diesel::sql_types::Text"]
/// A namespace (schema) in the database
pub struct Namespace(String);

impl Namespace {
    pub fn new(s: String) -> Result<Self, String> {
        // Normal database namespaces must be of the form `sgd[0-9]+`
        if !s.starts_with("sgd") || s.len() <= 3 {
            return Err(s);
        }
        for c in s.chars().skip(3) {
            if !c.is_numeric() {
                return Err(s);
            }
        }

        Ok(Namespace(s))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl fmt::Display for Namespace {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl FromSql<Text, Pg> for Namespace {
    fn from_sql(bytes: Option<&[u8]>) -> diesel::deserialize::Result<Self> {
        let s = <String as FromSql<Text, Pg>>::from_sql(bytes)?;
        Namespace::new(s).map_err(Into::into)
    }
}

impl ToSql<Text, Pg> for Namespace {
    fn to_sql<W: Write>(&self, out: &mut Output<W, Pg>) -> diesel::serialize::Result {
        <String as ToSql<Text, Pg>>::to_sql(&self.0, out)
    }
}

/// A marker that an `i32` references a deployment. Values of this type hold
/// the primary key from the `deployment_schemas` table
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, AsExpression, FromSqlRow)]
#[sql_type = "diesel::sql_types::Integer"]
pub struct DeploymentId(i32);

impl DeploymentId {
    pub fn new(id: i32) -> Self {
        Self(id)
    }
    pub fn value(&self) -> i32 {
        self.0
    }
}
impl fmt::Display for DeploymentId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl FromSql<Integer, Pg> for DeploymentId {
    fn from_sql(bytes: Option<&[u8]>) -> diesel::deserialize::Result<Self> {
        let id = <i32 as FromSql<Integer, Pg>>::from_sql(bytes)?;
        Ok(DeploymentId(id))
    }
}

impl ToSql<Integer, Pg> for DeploymentId {
    fn to_sql<W: Write>(&self, out: &mut Output<W, Pg>) -> diesel::serialize::Result {
        <i32 as ToSql<Integer, Pg>>::to_sql(&self.0, out)
    }
}
#[derive(Queryable, Clone, Debug, Identifiable, Serialize, Insertable, Deserialize)]
#[primary_key(v_id)]
pub struct Indexer {
    pub network: Option<String>,
    pub name: String,
    pub namespace: String,
    pub description: Option<String>,
    pub image_url: Option<String>,
    pub repository: Option<String>,
    pub manifest: String,
    pub mapping: String,
    pub graphql: String,
    pub status: IndexerStatus,
    pub deleted: bool,
    pub address: Option<String>,
    pub start_block: i64,
    pub got_block: i64,
    pub version: Option<String>,
    pub hash: String,
    pub v_id: i64,
}

impl Default for Indexer {
    fn default() -> Self {
        Self {
            network: None,
            name: "".to_string(),
            namespace: "".to_string(),
            description: None,
            image_url: None,
            repository: None,
            manifest: "".to_string(),
            mapping: "".to_string(),
            graphql: "".to_string(),
            status: Default::default(),
            deleted: false,
            address: None,
            start_block: 0,
            got_block: 0,
            version: None,
            hash: Uuid::new_v4().to_string(),
            v_id: 0,
        }
    }
}

type Bytes = Vec<u8>;

#[derive(Queryable, Clone, Debug, Identifiable, Insertable)]
#[table_name = "indexer_deployments"]
#[primary_key(id)]
// We map all fields to make loading `Detail` with diesel easier, but we
// don't need all the fields
#[allow(dead_code)]
pub struct Deployment {
    pub id: DeploymentId,
    pub hash: String,
    pub namespace: String,
    pub schema: String,
    pub failed: bool,
    health: IndexerHealth,
    pub synced: bool,
    fatal_error: Option<String>,
    non_fatal_errors: Vec<String>,
    earliest_block_hash: Option<Bytes>,
    earliest_block_number: Option<BigDecimal>,
    pub latest_block_hash: Option<Bytes>,
    pub latest_block_number: Option<BigDecimal>,
    last_healthy_block_hash: Option<Bytes>,
    last_healthy_block_number: Option<BigDecimal>,
    pub entity_count: BigDecimal,
    graft_base: Option<String>,
    graft_block_hash: Option<Bytes>,
    graft_block_number: Option<BigDecimal>,
    reorg_count: i32,
    current_reorg_depth: i32,
    max_reorg_depth: i32,
}

/// Information about the database schema that stores the entities for a
/// subgraph.
#[derive(Clone, Queryable, QueryableByName, Debug)]
#[table_name = "indexer_deployment_schemas"]
pub struct DeploymentSchema {
    pub id: DeploymentId,
    pub created_at: PgTimestamp,
    pub indexer_hash: String,
    ///name of schema ex: sgd4
    pub schema_name: String,
    pub shard: String,
    /// The version currently in use. Always `Relational`, attempts to load
    /// schemas from the database with `Split` produce an error
    pub network: String,
    pub active: bool,
}

#[derive(Clone, Queryable, QueryableByName, Debug)]
#[table_name = "unused_deployments"]
pub struct UnusedDeployment {
    pub id: DeploymentId,
    pub deployment: String,
    pub unused_at: PgTimestamp,
    pub removed_at: Option<PgTimestamp>,
    pub created_at: PgTimestamp,
    pub subgraphs: Option<Vec<String>>,
    pub namespace: String,
    pub shard: String,

    /// Data we fill in from the deployment's shard
    pub entity_count: i32,
    pub latest_ethereum_block_hash: Option<Vec<u8>>,
    pub latest_ethereum_block_number: Option<i32>,
    pub failed: bool,
    pub synced: bool,
}

///Structs for insert data
#[derive(Clone, Debug, Insertable)]
#[table_name = "indexer_deployments"]
pub struct DeploymentForm {
    pub hash: String,
    pub namespace: String,
    pub schema: String,
    pub failed: bool,
    pub health: IndexerHealth,
    pub synced: bool,
    pub fatal_error: Option<String>,
    pub non_fatal_errors: Vec<String>,
    pub earliest_block_hash: Option<Bytes>,
    pub earliest_block_number: Option<BigDecimal>,
    pub latest_block_hash: Option<Bytes>,
    pub latest_block_number: Option<BigDecimal>,
    pub last_healthy_block_hash: Option<Bytes>,
    pub last_healthy_block_number: Option<BigDecimal>,
    pub entity_count: BigDecimal,
    pub graft_base: Option<String>,
    pub graft_block_hash: Option<Bytes>,
    pub graft_block_number: Option<BigDecimal>,
    pub reorg_count: i32,
    pub current_reorg_depth: i32,
    pub max_reorg_depth: i32,
}

#[derive(Clone, Debug, Insertable)]
#[table_name = "indexer_deployment_schemas"]
pub struct DeploymentSchemaForm {
    pub created_at: PgTimestamp,
    pub indexer_hash: String,
    ///name of schema ex: sgd4
    pub schema_name: String,
    pub shard: String,
    /// The version currently in use. Always `Relational`, attempts to load
    /// schemas from the database with `Split` produce an error
    pub network: String,
    pub active: bool,
}
